<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>四种常用排序算法 | Daxian's Notes</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">四种常用排序算法</h1><a id="logo" href="/.">Daxian's Notes</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">四种常用排序算法</h1><div class="post-meta">May 23, 2018</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#相关概念："><span class="toc-number">1.</span> <span class="toc-text">相关概念：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、时间复杂度"><span class="toc-number">1.1.</span> <span class="toc-text">1、时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、空间复杂度"><span class="toc-number">1.2.</span> <span class="toc-text">2、空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序算法"><span class="toc-number">2.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-冒泡排序"><span class="toc-number">2.1.</span> <span class="toc-text">1.冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-算法原理："><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-算法实现（Java）："><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 算法实现（Java）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-选择排序"><span class="toc-number">2.2.</span> <span class="toc-text">2.选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-直接选择排序"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 直接选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-算法原理：-1"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">1.1 算法原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-算法实现（Java）：-1"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">1.2 算法实现（Java）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-插入排序"><span class="toc-number">2.3.</span> <span class="toc-text">3.插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-快速排序"><span class="toc-number">2.4.</span> <span class="toc-text">4.快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-算法原理："><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-算法实现（Java）："><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 算法实现（Java）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-算法原理："><span class="toc-number">2.4.3.</span> <span class="toc-text">5.1 算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-算法实现（Java）："><span class="toc-number">2.4.4.</span> <span class="toc-text">5.2 算法实现（Java）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Shell排序"><span class="toc-number">2.5.</span> <span class="toc-text">6. Shell排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-算法原理："><span class="toc-number">2.5.1.</span> <span class="toc-text">6.1 算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-算法实现（Java）："><span class="toc-number">2.5.2.</span> <span class="toc-text">6.2 算法实现（Java）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-堆排序"><span class="toc-number">2.6.</span> <span class="toc-text">7. 堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-算法原理："><span class="toc-number">2.6.1.</span> <span class="toc-text">7.1 算法原理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-归并排序"><span class="toc-number">2.7.</span> <span class="toc-text">8. 归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-算法原理："><span class="toc-number">2.7.1.</span> <span class="toc-text">8.1 算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-算法实现（Java）："><span class="toc-number">2.7.2.</span> <span class="toc-text">8.2 算法实现（Java）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-基数排序"><span class="toc-number">2.8.</span> <span class="toc-text">9. 基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-算法原理："><span class="toc-number">2.8.1.</span> <span class="toc-text">9.1 算法原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-算法实现（Java）："><span class="toc-number">2.8.2.</span> <span class="toc-text">9.2 算法实现（Java）：</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><h1 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h1><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><pre><code>时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)
时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),
</code></pre><h2 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h2><pre><code>空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数
空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)
空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)
                             ax=N，则x=logaN，
空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).
</code></pre><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>冒泡排序、选择排序、插入排序、快速排序、</p>
<hr>
<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>特点：效率低，实现简单<br>思想（从小到大排）：每一趟将待排序序列中（相邻）最大元素移到最后，剩下的为新的待排序序列，重复上述步骤直到排完所有元素。这只是冒泡排序的一种，当然也可以从后往前排。<br>public void bubbleSort(int array[]) {<br>        int t = 0;<br>        for (int i = 0; i &lt; array.length - 1; i++)<br>            for (int j = 0; j &lt; array.length - 1 - i; j++)<br>                if (array[j] &gt; array[j + 1]) {<br>                    t = array[j];<br>                    array[j] = array[j + 1];<br>                    array[j + 1] = t;<br>                }<br>    }</p>
<h3 id="1-1-算法原理："><a href="#1-1-算法原理：" class="headerlink" title="1.1 算法原理："></a>1.1 算法原理：</h3><p>S1：从待排序序列的起始位置开始，从前往后依次比较各个位置和其后一位置的大小并执行S2。<br>S2：如果当前位置的值大于其后一位置的值，就把他俩的值交换（完成一次全序列比较后，序列最后位置的值即此序列最大值，所以其不需要再参与冒泡）。<br>S3：将序列的最后位置从待排序序列中移除。若移除后的待排序序列不为空则继续执行S1，否则冒泡结束。</p>
<h3 id="1-2-算法实现（Java）："><a href="#1-2-算法实现（Java）：" class="headerlink" title="1.2 算法实现（Java）："></a>1.2 算法实现（Java）：</h3><p>1.2.1 基础实现：<br>public static void bubbleSort(int[] array) {<br>    int len = array.length;<br>    for (int i = 0; i &lt; len; i++) {<br>        for (int j = 0; j &lt; len - i - 1; j++) {<br>            if (array[j] &gt; array[j + 1]) {<br>                int temp = array[j + 1];<br>                array[j + 1] = array[j];<br>                array[j] = temp;<br>            }<br>        }<br>    }<br>}<br>1.2.2 算法优化：<br>若某一趟排序中未进行一次交换，则排序结束<br>public static void bubbleSort(int[] array) {<br>    int len = array.length;<br>    boolean flag = true;<br>    while (flag) {<br>        flag = false;<br>        for (int i = 0; i &lt; len - 1; i++) {<br>            if (array[i] &gt; array[i + 1]) {<br>                int temp = array[i + 1];<br>                array[i + 1] = array[j];<br>                array[i] = temp;<br>                flag = true;<br>            }<br>        }<br>        len–;<br>    }<br>}</p>
<hr>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>特点：效率低，容易实现。<br>思想：每一趟从待排序序列选择一个最小的元素放到已排好序序列的末尾，剩下的位待排序序列，重复上述步骤直到完成排序。<br>public void selectSort(int array[]) {<br>        int t = 0;<br>        for (int i = 0; i &lt; array.length - 1; i++)<br>            for (int j = i + 1; j &lt; array.length; j++)<br>                if (array[i] &gt; array[j]) {<br>                    t = array[i];<br>                    array[i] = array[j];<br>                    array[j] = t;<br>                }<br>    }</p>
<h3 id="1-直接选择排序"><a href="#1-直接选择排序" class="headerlink" title="1. 直接选择排序"></a>1. 直接选择排序</h3><h4 id="1-1-算法原理：-1"><a href="#1-1-算法原理：-1" class="headerlink" title="1.1 算法原理："></a>1.1 算法原理：</h4><p>直接选择排序是一种简单的排序方法，它的基本思想是：<br>第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，<br>第二次从R[1]~R[n-1]中选取最小值，与R[1]交换，<br>….，<br>第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，<br>…..，<br>第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，<br>共通过n-1次，得到一个从小到大排列的有序序列。</p>
<h4 id="1-2-算法实现（Java）：-1"><a href="#1-2-算法实现（Java）：-1" class="headerlink" title="1.2 算法实现（Java）："></a>1.2 算法实现（Java）：</h4><p>public static void selectSort(int[] array) {<br>    int n = array.length;<br>    for (int i = 0; i &lt; n; i++) {<br>        int minIndex = i;<br>        for (int j = i + 1; j &lt; n; j++) {<br>            if (array[minIndex] &gt; array[j]) {<br>                minIndex = j;<br>            }<br>        }<br>        if (i != minIndex) {<br>            int temp = array[i];<br>            array[i] = array[minIndex];<br>            array[minIndex] = temp;<br>        }<br>    }<br>}</p>
<hr>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>特点：效率低，容易实现。<br>思想：将数组分为两部分，将后部分元素逐一与前部分元素比较，如果当前元素array[i]小，就替换。找到合理位置插入array[i]<br>public void insertionSort(int array[]) {<br>        int i, j, t = 0;<br>        for (i = 1; i &lt; array.length; i++) {<br>            t = array[i];<br>            for (j = i - 1; j &gt;= 0 &amp;&amp; t &lt; array[j]; j–)<br>                array[j + 1] = array[j];<br>            array[j + 1] = t;<br>        }<br>    }</p>
<hr>
<h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h2><p>特点：高效，时间复杂度为nlogn。<br>采用分治法的思想：首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分，接下来对划分完的子序列进行快排直到子序列为一个元素为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int array[], int low, int high) &#123;// 传入low=0，high=array.length-1;</span><br><span class="line">        int pivot, p_pos, i, t;// pivot-&gt;位索引;p_pos-&gt;轴值。</span><br><span class="line">        if (low &lt; high) &#123;</span><br><span class="line">            p_pos = low;</span><br><span class="line">            pivot = array[p_pos];</span><br><span class="line">            for (i = low + 1; i &lt;= high; i++)</span><br><span class="line">                if (array[i] &gt; pivot) &#123;</span><br><span class="line">                    p_pos++;</span><br><span class="line">                    t = array[p_pos];</span><br><span class="line">                    array[p_pos] = array[i];</span><br><span class="line">                    array[i] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            t = array[low];</span><br><span class="line">            array[low] = array[p_pos];</span><br><span class="line">            array[p_pos] = t;</span><br><span class="line">            // 分而治之</span><br><span class="line">            quickSort(array, low, p_pos - 1);// 排序左半部分</span><br><span class="line">            quickSort(array, p_pos + 1, high);// 排序右半部分</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static void quickSort(int[] a, int low, int high) &#123;  </span><br><span class="line"> 2.         //1,找到递归算法的出口  </span><br><span class="line"> 3.         if( low &gt; high) &#123;  </span><br><span class="line"> 4.             return;  </span><br><span class="line"> 5.         &#125;  </span><br><span class="line"> 6.         //2, 存  </span><br><span class="line"> 7.         int i = low;  </span><br><span class="line"> 8.         int j = high;  </span><br><span class="line"> 9.         //3,key  </span><br><span class="line"> 10.         int key = a[ low ];  </span><br><span class="line"> 11.         //4，完成一趟排序  </span><br><span class="line"> 12.         while( i&lt; j) &#123;  </span><br><span class="line"> 13.             //4.1 ，从右往左找到第一个小于key的数  </span><br><span class="line"> 14.             while(i&lt;j &amp;&amp; a[j] &gt; key)&#123;  </span><br><span class="line"> 15.                 j--;  </span><br><span class="line"> 16.             &#125;  </span><br><span class="line"> 17.             // 4.2 从左往右找到第一个大于key的数  </span><br><span class="line"> 18.             while( i&lt;j &amp;&amp; a[i] &lt;= key) &#123;  </span><br><span class="line"> 19.                 i++;  </span><br><span class="line"> 20.             &#125;  </span><br><span class="line"> 21.             //4.3 交换  </span><br><span class="line"> 22.             if(i&lt;j) &#123;  </span><br><span class="line"> 23.                 int p = a[i];  </span><br><span class="line"> 24.                 a[i] = a[j];  </span><br><span class="line"> 25.                 a[j] = p;  </span><br><span class="line"> 26.             &#125;  </span><br><span class="line"> 27.         &#125;  </span><br><span class="line"> 28.         // 4.4，调整key的位置  </span><br><span class="line"> 29.         int p = a[i];  </span><br><span class="line"> 30.         a[i] = a[low];  </span><br><span class="line"> 31.         a[low] = p;  </span><br><span class="line"> 32.         //5, 对key左边的数快排  </span><br><span class="line"> 33.         quickSort(a, low, i-1 );  </span><br><span class="line"> 34.         //6, 对key右边的数快排  </span><br><span class="line"> 35.         quickSort(a, i+1, high);  </span><br><span class="line"> 36.     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-算法原理："><a href="#4-1-算法原理：" class="headerlink" title="4.1 算法原理："></a>4.1 算法原理：</h3><p>快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此实现整个数据变成有序序列。</p>
<h3 id="4-2-算法实现（Java）："><a href="#4-2-算法实现（Java）：" class="headerlink" title="4.2 算法实现（Java）："></a>4.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] array, int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int pivot = array[left];</span><br><span class="line">        int low = left;</span><br><span class="line">        int high = right;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            while (low &lt; high &amp;&amp; array[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[low] = array[high];</span><br><span class="line">            while (low &lt; high &amp;&amp; array[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            array[high] = array[low];</span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = pivot;</span><br><span class="line">        quickSort(array, left, low - 1);</span><br><span class="line">        quickSort(array, low + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>##5. 直接插入排序</p>
<h3 id="5-1-算法原理："><a href="#5-1-算法原理：" class="headerlink" title="5.1 算法原理："></a>5.1 算法原理：</h3><p>插入排序的基本方法是：每步将一个待排序序列按数据大小插到前面已经排序的序列中的适当位置，直到全部数据插入完毕为止。<br>假设有一组无序序列 , , … , ：<br>(1) 将这个序列的第一个元素R0视为一个有序序列；<br>(2) 依次把 , , … ,  插入到这个有序序列中；<br>(3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。</p>
<h3 id="5-2-算法实现（Java）："><a href="#5-2-算法实现（Java）：" class="headerlink" title="5.2 算法实现（Java）："></a>5.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] array) &#123;</span><br><span class="line">    for (int i = 1, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (array[i] &lt; array[i - 1]) &#123;</span><br><span class="line">            int temp = array[i];</span><br><span class="line">            int j;</span><br><span class="line">            for (j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j--) &#123;</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-Shell排序"><a href="#6-Shell排序" class="headerlink" title="6. Shell排序"></a>6. Shell排序</h2><h3 id="6-1-算法原理："><a href="#6-1-算法原理：" class="headerlink" title="6.1 算法原理："></a>6.1 算法原理：</h3><p>希尔排序是一种插入排序算法，又称作缩小增量排序。是对直接插入排序算法的改进。其基本思想是：<br>先取一个小于n的整数作为第一个增量，把全部数据分成个组。所有距离为的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量重复上述的分组和排序，直至所取的增量，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。</p>
<h3 id="6-2-算法实现（Java）："><a href="#6-2-算法实现（Java）：" class="headerlink" title="6.2 算法实现（Java）："></a>6.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] array) &#123;</span><br><span class="line">    int n = array.length;</span><br><span class="line">    int h;</span><br><span class="line">    for (h = n / 2; h &gt; 0; h /= 2) &#123;</span><br><span class="line">        for (int i = h; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = i - h; j &gt;= 0; j -= h) &#123;</span><br><span class="line">                if (array[j] &gt; array[j + h]) &#123;</span><br><span class="line">                    int temp = array[j];</span><br><span class="line">                    array[j] = array[j + h];</span><br><span class="line">                    array[j + h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><h3 id="7-1-算法原理："><a href="#7-1-算法原理：" class="headerlink" title="7.1 算法原理："></a>7.1 算法原理：</h3><p>6.1.1 二叉堆定义：<br>二叉堆是完全二叉树或近似完全二叉树。二叉堆满足两个特性：<br>  1）父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>  2）每个结点的左子树和右子树都是一个二叉堆。<br>当父结点的键值总是大于或等于任何一个子节点的键值时为大根堆。当父结点的键值总是小于或等于任何一个子节点的键值时为小根堆。下面展示一个小根堆： </p>
<p>由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。<br>6.1.2 堆的存储：<br>一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 <em> i + 1和2 </em> i + 2。如第0个结点左右子结点下标分别为1和2。 </p>
<p>6.1.3 堆的插入：<br>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，然后将这个新数据插入到这个有序数据中。<br>6.1.4 堆排序：<br>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]，小根堆则相反。<br>堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。<br>（1）用大根堆排序的基本思想<br>  ① 先将初始数组建成一个大根堆，此堆为初始的无序区<br>  ② 再将最大的元素（即堆顶）和无序区的最后一个记录交换，由此得到新的无序区和有序区，且满足的值&lt;=的值。<br>  ③由于交换后新的根可能违反堆性质，故应将当前无序区调整为堆。然后再次将中最大的元素和该区间的最后一个记录交换，由此得到新的无序区和有序区，且仍满足关系的值&lt;=的值，同样要将调整为堆。<br>……<br>直到无序区只有一个元素为止。<br>（2）大根堆排序算法的基本操作：<br>  ①建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。<br>  ②调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。<br>  ③堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。</p>
<p>###7.2 算法实现（Java）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void heapSort(int[] array) &#123;</span><br><span class="line">    // 1. 创建最大堆：从最后一个节点的父节点开始</span><br><span class="line">    int lastIndex = array.length - 1;</span><br><span class="line">    int startIndex = (lastIndex - 1) / 2;</span><br><span class="line">    for (int i = startIndex; i &gt;= 0; i--) &#123;</span><br><span class="line">        maxHeap(sort, sort.length, i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. 排序：末尾与头交换，逐一找出最大值，最终形成一个递增的有序序列</span><br><span class="line">    for (int i = array.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        int temp = array[0];</span><br><span class="line">        array[0] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        maxHeap(array, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static void maxHeap(int[] data, int heapSize, int index) &#123;</span><br><span class="line">    // 左子节点</span><br><span class="line">    int leftChild = 2 * index + 1;</span><br><span class="line">    // 右子节点</span><br><span class="line">    int rightChild = 2 * index + 2;</span><br><span class="line">    // 最大元素下标</span><br><span class="line">    int largestIndex = index;</span><br><span class="line">    // 分别比较当前节点和左右子节点，找出最大值</span><br><span class="line">    if (leftChild &lt; heapSize &amp;&amp; data[leftChild] &gt; data[largestIndex]) &#123;</span><br><span class="line">        largestIndex = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rightChild &lt; heapSize &amp;&amp; data[rightChild] &gt; data[largestIndex]) &#123;</span><br><span class="line">        largestIndex = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果最大值是子节点，则进行交换</span><br><span class="line">    if (largestIndex != index) &#123;</span><br><span class="line">        int temp = data[index];</span><br><span class="line">        data[index] = data[largestIndex];</span><br><span class="line">        data[largestIndex] = temp;</span><br><span class="line">        // 交换后，其子节点可能就不是最大堆了，需要对交换的子节点重新调整</span><br><span class="line">        maxHeap(data, heapSize, largestIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8. 归并排序"></a>8. 归并排序</h2><h3 id="8-1-算法原理："><a href="#8-1-算法原理：" class="headerlink" title="8.1 算法原理："></a>8.1 算法原理：</h3><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并过程为：<br>  比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。<br>归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。<br>归并操作的工作原理如下：<br>  S1: 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>  S2: 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>  S3: 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>  S4: 重复S3，直到某一指针超出序列尾<br>  S5: 将另一序列剩下的所有元素直接复制到合并序列尾</p>
<h3 id="8-2-算法实现（Java）："><a href="#8-2-算法实现（Java）：" class="headerlink" title="8.2 算法实现（Java）："></a>8.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void mergeSort(int[] array, int low, int high) &#123;</span><br><span class="line">    int middle = (low + high) / 2;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        mergeSort(array, low, middle);</span><br><span class="line">        mergeSort(array, middle + 1, high);</span><br><span class="line">        merge(array, low, middle, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(int[] array, int low, int middle, int high) &#123;</span><br><span class="line">    int[] temp = new int[high - low + 1];</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = middle + 1;</span><br><span class="line">    int k = 0;</span><br><span class="line">    while (i &lt;= middle &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        if (array[i] &lt; array[j]) &#123;</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= middle) &#123;</span><br><span class="line">        temp[k++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int m = 0; m &lt; temp.length; m++) &#123;</span><br><span class="line">        array[m + low] = temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9. 基数排序"></a>9. 基数排序</h2><h3 id="9-1-算法原理："><a href="#9-1-算法原理：" class="headerlink" title="9.1 算法原理："></a>9.1 算法原理：</h3><p>基数排序的原理如下：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序的方式有以下两种：<br>  最高位优先(Most Significant Digit first)法，简称MSD法：先按排序分组，同一组中记录，关键码相等，再对各组按排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码对各子组排序后。再将各组连接起来，便得到一个有序序列。<br>  最低位优先(Least Significant Digit first)法，简称LSD法：先从开始排序，再对进行排序，依次重复，直到对排序后便得到一个有序序列。</p>
<h3 id="9-2-算法实现（Java）："><a href="#9-2-算法实现（Java）：" class="headerlink" title="9.2 算法实现（Java）："></a>9.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序(LSD)</span><br><span class="line"> *</span><br><span class="line"> * @param array 待排序数组</span><br><span class="line"> * @param d     表示最大的元素的位数</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] array, int d) &#123;</span><br><span class="line">    int n = 1;</span><br><span class="line">    int times = 1; // 排序次数，由位数最多的元素决定</span><br><span class="line">    int[][] temp = new int[10][array.length]; //数组的第一维表示可能的余数0-9</span><br><span class="line">    int[] order = new int[10]; //数组order用来表示该位是i的元素个数</span><br><span class="line">    while (times &lt;= d) &#123;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            int lsd = ((array[i] / n) % 10);</span><br><span class="line">            temp[lsd][order[lsd]] = array[i];</span><br><span class="line">            order[lsd]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 0;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (order[i] != 0) &#123;</span><br><span class="line">                for (int j = 0; j &lt; order[i]; j++) &#123;</span><br><span class="line">                    array[k] = temp[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                order[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= 10;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/05/23/二分查找、二叉树/">二叉树、二分查找</a><a class="next" href="/2018/05/20/Android git需要忽略文件/">Android git需要忽略文件</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/MVP/">MVP</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/GreenDAO/">GreenDAO</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Markdown/">Markdown</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/config/" style="font-size: 15px;">config</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/CountDownTimer/" style="font-size: 15px;">CountDownTimer</a> <a href="/tags/English/" style="font-size: 15px;">English</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/basis/" style="font-size: 15px;">basis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/09/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/英语二·蒋军虎每日一句/">英语二·蒋军虎每日一句</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/二分查找、二叉树/">二叉树、二分查找</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/23/Java排序相关/">四种常用排序算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/20/Android git需要忽略文件/">Android git需要忽略文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/20/GreenDao理解及简单使用/">GreenDao理解及简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/CountDownTimer使用和源码学习/">CountDownTimer</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/Activity横竖切换/">Android横竖切换</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/09/Markdown语法/">Markdown语法</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/30/MVC,MVP,MVVM的图示/">MVC,MVP,MVVM的图示</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://wanandroid.com/" title="wanandroid" target="_blank">wanandroid</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">Daxian's Notes.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>