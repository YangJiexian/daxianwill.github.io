<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/09/hello-world/"/>
      <url>/2019/03/09/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>英语二·蒋军虎每日一句</title>
      <link href="/2018/06/01/%E8%8B%B1%E8%AF%AD%E4%BA%8C%C2%B7%E8%92%8B%E5%86%9B%E8%99%8E%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/"/>
      <url>/2018/06/01/%E8%8B%B1%E8%AF%AD%E4%BA%8C%C2%B7%E8%92%8B%E5%86%9B%E8%99%8E%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="英语二·蒋军虎每日一句"><a href="#英语二·蒋军虎每日一句" class="headerlink" title="英语二·蒋军虎每日一句"></a>英语二·蒋军虎每日一句</h1><h2 id="June"><a href="#June" class="headerlink" title="June"></a>June</h2><h3 id="6-2-—1"><a href="#6-2-—1" class="headerlink" title="6.2    —1"></a>6.2    —1</h3><p><strong>Since technology has such an insatiable appetite for eating up human jobs,this phenomenon will continue to restructure our economy in ways we can’t immediately foresee.</strong></p><h3 id="6-1-—2"><a href="#6-1-—2" class="headerlink" title="6.1    —2"></a>6.1    —2</h3><p><strong>It’s not that people’s profiles are dishonest,says Catalina Toma of Wisconsin-Mandison University,”but they protray an idealized version of themselves”.</strong></p><p>1/2/3</p><h2 id="May"><a href="#May" class="headerlink" title="May"></a>May</h2><h3 id="5-31-—3"><a href="#5-31-—3" class="headerlink" title="5.31    —3"></a>5.31    —3</h3><p><strong>Facebook,therefore,is a self-enhancer’s paradise,where people can share only the most flattering photos,the cream of their wit,style,beauty,intellect and lifestyle.</strong></p><h3 id="5-30-—4"><a href="#5-30-—4" class="headerlink" title="5.30    —4"></a>5.30    —4</h3><p><strong>Knowing the results of  Epley’s study, it makes sense that many people hate photographs of themselves so viscerally-on one level,the don’t even recognise the person in the picture as themselves.</strong></p><h3 id="5-29-—5"><a href="#5-29-—5" class="headerlink" title="5.29    —5"></a>5.29    —5</h3><p><strong>In fact,those who thought that the images higher up the attractiveness scale were real directly corresponded with those who showed other markers for having higher self-esteem</strong></p><h3 id="5-28-—6"><a href="#5-28-—6" class="headerlink" title="5.28    —6"></a>5.28    —6</h3><p><strong>Nor was there any evidence that those who self-enhanced the most (that is, the participants who thought the most positively doctored pictures were real) were doing so to make up for profound insecurities.</strong></p><h3 id="5-26-—7"><a href="#5-26-—7" class="headerlink" title="5.26    —7"></a>5.26    —7</h3><p><strong>Visual recognition , read the study ,is “an automatic psychological process occurring rapidly and intuitively with little or no apparent conscious deliberation”.</strong></p><h3 id="5-25-—8"><a href="#5-25-—8" class="headerlink" title="5.25    —8"></a>5.25    —8</h3><p><strong>Rather than have people simply rate their beauty compared with others,he asked them to identify an original photograph of themselves from a lineup including versions that had been altered to appear more and less attractive.</strong></p><h3 id="5-24-—9"><a href="#5-24-—9" class="headerlink" title="5.24    —9"></a>5.24    —9</h3><hr><h3 id="5-23-—10"><a href="#5-23-—10" class="headerlink" title="5.23    —10"></a>5.23    —10</h3>]]></content>
      
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树、二分查找</title>
      <link href="/2018/05/23/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/05/23/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="java实现简单的二叉树"><a href="#java实现简单的二叉树" class="headerlink" title="java实现简单的二叉树"></a>java实现简单的二叉树</h2><p>二叉排序树,平衡二叉树,红黑树都是在普通二叉树的基础上构建的,所以很有必要学习一下二叉树。<br>二叉树的遍历:<br>1:先序遍历(DLR)<br>  1):访问根节点;<br>  2):按先序遍历访问左子树<br>  3):按先序遍历访问右子树<br>2:中序遍历(LRD)<br> 1):按中序遍历左子树<br> 2):访问根节点<br> 3):按中序遍历访问右子树<br>3:后序遍历<br> 1):按后序遍历访问左子树<br> 2):按后序遍历访问右子树<br> 3):访问根节点</p><p>先序遍历的结果为:0  1   3  7  4  2  5  6<br>中序遍历的结果为:7   3   1  4  0  5  2  6<br>后序遍历的结果为:7   3   4  1  5  6  2  0<br>java代码实现:<br>BinTree类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[java] view plain copy</span><br><span class="line">   public class BinTree &#123;  </span><br><span class="line">       private BinTree lChild;//左孩子  </span><br><span class="line">       private BinTree rChild;//右孩子  </span><br><span class="line">       private BinTree root;//根节点  </span><br><span class="line">       private Object data; //数据域  </span><br><span class="line">       private List&lt;BinTree&gt; datas;//存储所有的节点  </span><br><span class="line">       public BinTree(BinTree lChild, BinTree rChild, Object data) &#123;  </span><br><span class="line">           super();  </span><br><span class="line">           this.lChild = lChild;  </span><br><span class="line">           this.rChild = rChild;  </span><br><span class="line">           this.data = data;  </span><br><span class="line">       &#125;  </span><br><span class="line">       public BinTree(Object data) &#123;  </span><br><span class="line">           this(null, null, data);  </span><br><span class="line">       &#125;  </span><br><span class="line">       public BinTree() &#123;  </span><br><span class="line">           super();  </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">       public void createTree(Object[] objs)&#123;  </span><br><span class="line">           datas=new ArrayList&lt;BinTree&gt;();  </span><br><span class="line">           for (Object object : objs) &#123;  </span><br><span class="line">               datas.add(new BinTree(object));  </span><br><span class="line">           &#125;  </span><br><span class="line">           root=datas.get(0);//将第一个作为根节点  </span><br><span class="line">           for (int i = 0; i &lt; objs.length/2; i++) &#123;  </span><br><span class="line">              datas.get(i).lChild=datas.get(i*2+1);  </span><br><span class="line">              if(i*2+2&lt;datas.size())&#123;//避免偶数的时候 下标越界  </span><br><span class="line">                  datas.get(i).rChild=datas.get(i*2+2);  </span><br><span class="line">              &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">       &#125;  </span><br><span class="line">       //先序遍历  </span><br><span class="line">       public void preorder(BinTree root)&#123;  </span><br><span class="line">           if(root!=null)&#123;  </span><br><span class="line">               visit(root.getData());  </span><br><span class="line">              preorder(root.lChild);  </span><br><span class="line">               preorder(root.rChild);  </span><br><span class="line">           &#125;  </span><br><span class="line">            </span><br><span class="line">       &#125;  </span><br><span class="line">       //中序遍历  </span><br><span class="line">       public void inorder(BinTree root)&#123;  </span><br><span class="line">           if(root!=null)&#123;  </span><br><span class="line">              inorder(root.lChild);  </span><br><span class="line">               visit(root.getData());  </span><br><span class="line">               inorder(root.rChild);  </span><br><span class="line">           &#125;  </span><br><span class="line">             </span><br><span class="line">       &#125;  </span><br><span class="line">       //后序遍历  </span><br><span class="line">       public void afterorder(BinTree root)&#123;  </span><br><span class="line">           if(root!=null)&#123;  </span><br><span class="line">               afterorder(root.lChild);  </span><br><span class="line">               afterorder(root.rChild);  </span><br><span class="line">              visit(root.getData());  </span><br><span class="line">           &#125;  </span><br><span class="line">            </span><br><span class="line">       &#125;  </span><br><span class="line">       private void visit(Object obj) &#123;  </span><br><span class="line">           System.out.print(obj+&quot; &quot;);  </span><br><span class="line">       &#125;  </span><br><span class="line">     public Object getData() &#123;  </span><br><span class="line">          return data;  </span><br><span class="line">     &#125;  </span><br><span class="line">     public BinTree getRoot() &#123;  </span><br><span class="line">           return root;  </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>测试类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[java] view plain copy</span><br><span class="line">  public class TestTree &#123;  </span><br><span class="line">      public static void main(String[] args) &#123;  </span><br><span class="line">           BinTree binTree=new BinTree();  </span><br><span class="line">           Object[] objs=&#123;0,1,2,3,4,5,6,7&#125;;  </span><br><span class="line">           binTree.createTree(objs);  </span><br><span class="line">  //      binTree.preorder(binTree.getRoot()); 先序遍历  </span><br><span class="line">  //      binTree.inorder(binTree.getRoot()); 中序遍历  </span><br><span class="line">           binTree.afterorder(binTree.getRoot()); //后序遍历  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 使用递归的二分查找 </span><br><span class="line"> */  </span><br><span class="line">   </span><br><span class="line">public static int recursionBinarySearch(int[] arr,int key,int low,int high)&#123;  </span><br><span class="line">         </span><br><span class="line">       if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;  </span><br><span class="line">          return -1;                </span><br><span class="line">       &#125;  </span><br><span class="line">         </span><br><span class="line">       int middle = (low + high) / 2;          //初始中间位置  </span><br><span class="line">       if(arr[middle] &gt; key)&#123;  </span><br><span class="line">           //比关键字大则关键字在左区域  </span><br><span class="line">           return recursionBinarySearch(arr, key, low, middle - 1);  </span><br><span class="line">       &#125;else if(arr[middle] &lt; key)&#123;  </span><br><span class="line">           //比关键字小则关键字在右区域  </span><br><span class="line">           return recursionBinarySearch(arr, key, middle + 1, high);  </span><br><span class="line">       &#125;else &#123;  </span><br><span class="line">           return middle;  </span><br><span class="line">       &#125;     </span><br><span class="line">         </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 不使用递归的二分查找 </span><br><span class="line"> */  </span><br><span class="line">  public static int commonBinarySearch(int[] arr,int key)&#123;  </span><br><span class="line">      int low = 0;  </span><br><span class="line">      int high = arr.length - 1;  </span><br><span class="line">      int middle = 0;         //定义middle  </span><br><span class="line">        </span><br><span class="line">      if(key &lt; arr[low] || key &gt; arr[high] || low &gt; high)&#123;  </span><br><span class="line">          return -1;                </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      while(low &lt;= high)&#123;  </span><br><span class="line">          middle = (low + high) / 2;  </span><br><span class="line">          if(arr[middle] &gt; key)&#123;  </span><br><span class="line">             //比关键字大则关键字在左区域  </span><br><span class="line">              high = middle - 1;  </span><br><span class="line">          &#125;else if(arr[middle] &lt; key)&#123;  </span><br><span class="line">             //比关键字小则关键字在右区域  </span><br><span class="line">              low = middle + 1;  </span><br><span class="line">          &#125;else&#123;  </span><br><span class="line">              return middle;  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">        </span><br><span class="line">      return -1;      //最后仍然没有找到，则返回-1  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>四种常用排序算法</title>
      <link href="/2018/05/23/Java%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/05/23/Java%E6%8E%92%E5%BA%8F%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念："><a href="#相关概念：" class="headerlink" title="相关概念："></a>相关概念：</h1><h2 id="1、时间复杂度"><a href="#1、时间复杂度" class="headerlink" title="1、时间复杂度"></a>1、时间复杂度</h2><pre><code>时间复杂度可以认为是对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)时间复杂度O(1)：算法中语句执行次数为一个常数，则时间复杂度为O(1),</code></pre><h2 id="2、空间复杂度"><a href="#2、空间复杂度" class="headerlink" title="2、空间复杂度"></a>2、空间复杂度</h2><pre><code>空间复杂度是指算法在计算机内执行时所需存储空间的度量，它也是问题规模n的函数空间复杂度O(1)：当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)空间复杂度O(log2N)：当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为O(log2n)                             ax=N，则x=logaN，空间复杂度O(n)：当一个算法的空间复杂度与n成线性比例关系时，可表示为0(n).</code></pre><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>冒泡排序、选择排序、插入排序、快速排序、</p><hr><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>特点：效率低，实现简单<br>思想（从小到大排）：每一趟将待排序序列中（相邻）最大元素移到最后，剩下的为新的待排序序列，重复上述步骤直到排完所有元素。这只是冒泡排序的一种，当然也可以从后往前排。<br>public void bubbleSort(int array[]) {<br>        int t = 0;<br>        for (int i = 0; i &lt; array.length - 1; i++)<br>            for (int j = 0; j &lt; array.length - 1 - i; j++)<br>                if (array[j] &gt; array[j + 1]) {<br>                    t = array[j];<br>                    array[j] = array[j + 1];<br>                    array[j + 1] = t;<br>                }<br>    }</p><h3 id="1-1-算法原理："><a href="#1-1-算法原理：" class="headerlink" title="1.1 算法原理："></a>1.1 算法原理：</h3><p>S1：从待排序序列的起始位置开始，从前往后依次比较各个位置和其后一位置的大小并执行S2。<br>S2：如果当前位置的值大于其后一位置的值，就把他俩的值交换（完成一次全序列比较后，序列最后位置的值即此序列最大值，所以其不需要再参与冒泡）。<br>S3：将序列的最后位置从待排序序列中移除。若移除后的待排序序列不为空则继续执行S1，否则冒泡结束。</p><h3 id="1-2-算法实现（Java）："><a href="#1-2-算法实现（Java）：" class="headerlink" title="1.2 算法实现（Java）："></a>1.2 算法实现（Java）：</h3><p>1.2.1 基础实现：<br>public static void bubbleSort(int[] array) {<br>    int len = array.length;<br>    for (int i = 0; i &lt; len; i++) {<br>        for (int j = 0; j &lt; len - i - 1; j++) {<br>            if (array[j] &gt; array[j + 1]) {<br>                int temp = array[j + 1];<br>                array[j + 1] = array[j];<br>                array[j] = temp;<br>            }<br>        }<br>    }<br>}<br>1.2.2 算法优化：<br>若某一趟排序中未进行一次交换，则排序结束<br>public static void bubbleSort(int[] array) {<br>    int len = array.length;<br>    boolean flag = true;<br>    while (flag) {<br>        flag = false;<br>        for (int i = 0; i &lt; len - 1; i++) {<br>            if (array[i] &gt; array[i + 1]) {<br>                int temp = array[i + 1];<br>                array[i + 1] = array[j];<br>                array[i] = temp;<br>                flag = true;<br>            }<br>        }<br>        len–;<br>    }<br>}</p><hr><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>特点：效率低，容易实现。<br>思想：每一趟从待排序序列选择一个最小的元素放到已排好序序列的末尾，剩下的位待排序序列，重复上述步骤直到完成排序。<br>public void selectSort(int array[]) {<br>        int t = 0;<br>        for (int i = 0; i &lt; array.length - 1; i++)<br>            for (int j = i + 1; j &lt; array.length; j++)<br>                if (array[i] &gt; array[j]) {<br>                    t = array[i];<br>                    array[i] = array[j];<br>                    array[j] = t;<br>                }<br>    }</p><h3 id="1-直接选择排序"><a href="#1-直接选择排序" class="headerlink" title="1. 直接选择排序"></a>1. 直接选择排序</h3><h4 id="1-1-算法原理：-1"><a href="#1-1-算法原理：-1" class="headerlink" title="1.1 算法原理："></a>1.1 算法原理：</h4><p>直接选择排序是一种简单的排序方法，它的基本思想是：<br>第一次从R[0]~R[n-1]中选取最小值，与R[0]交换，<br>第二次从R[1]~R[n-1]中选取最小值，与R[1]交换，<br>….，<br>第i次从R[i-1]~R[n-1]中选取最小值，与R[i-1]交换，<br>…..，<br>第n-1次从R[n-2]~R[n-1]中选取最小值，与R[n-2]交换，<br>共通过n-1次，得到一个从小到大排列的有序序列。</p><h4 id="1-2-算法实现（Java）：-1"><a href="#1-2-算法实现（Java）：-1" class="headerlink" title="1.2 算法实现（Java）："></a>1.2 算法实现（Java）：</h4><p>public static void selectSort(int[] array) {<br>    int n = array.length;<br>    for (int i = 0; i &lt; n; i++) {<br>        int minIndex = i;<br>        for (int j = i + 1; j &lt; n; j++) {<br>            if (array[minIndex] &gt; array[j]) {<br>                minIndex = j;<br>            }<br>        }<br>        if (i != minIndex) {<br>            int temp = array[i];<br>            array[i] = array[minIndex];<br>            array[minIndex] = temp;<br>        }<br>    }<br>}</p><hr><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>特点：效率低，容易实现。<br>思想：将数组分为两部分，将后部分元素逐一与前部分元素比较，如果当前元素array[i]小，就替换。找到合理位置插入array[i]<br>public void insertionSort(int array[]) {<br>        int i, j, t = 0;<br>        for (i = 1; i &lt; array.length; i++) {<br>            t = array[i];<br>            for (j = i - 1; j &gt;= 0 &amp;&amp; t &lt; array[j]; j–)<br>                array[j + 1] = array[j];<br>            array[j + 1] = t;<br>        }<br>    }</p><hr><h2 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h2><p>特点：高效，时间复杂度为nlogn。<br>采用分治法的思想：首先设置一个轴值pivot，然后以这个轴值为划分基准将待排序序列分成比pivot大和比pivot小的两部分，接下来对划分完的子序列进行快排直到子序列为一个元素为止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void quickSort(int array[], int low, int high) &#123;// 传入low=0，high=array.length-1;</span><br><span class="line">        int pivot, p_pos, i, t;// pivot-&gt;位索引;p_pos-&gt;轴值。</span><br><span class="line">        if (low &lt; high) &#123;</span><br><span class="line">            p_pos = low;</span><br><span class="line">            pivot = array[p_pos];</span><br><span class="line">            for (i = low + 1; i &lt;= high; i++)</span><br><span class="line">                if (array[i] &gt; pivot) &#123;</span><br><span class="line">                    p_pos++;</span><br><span class="line">                    t = array[p_pos];</span><br><span class="line">                    array[p_pos] = array[i];</span><br><span class="line">                    array[i] = t;</span><br><span class="line">                &#125;</span><br><span class="line">            t = array[low];</span><br><span class="line">            array[low] = array[p_pos];</span><br><span class="line">            array[p_pos] = t;</span><br><span class="line">            // 分而治之</span><br><span class="line">            quickSort(array, low, p_pos - 1);// 排序左半部分</span><br><span class="line">            quickSort(array, p_pos + 1, high);// 排序右半部分</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private static void quickSort(int[] a, int low, int high) &#123;  </span><br><span class="line"> 2.         //1,找到递归算法的出口  </span><br><span class="line"> 3.         if( low &gt; high) &#123;  </span><br><span class="line"> 4.             return;  </span><br><span class="line"> 5.         &#125;  </span><br><span class="line"> 6.         //2, 存  </span><br><span class="line"> 7.         int i = low;  </span><br><span class="line"> 8.         int j = high;  </span><br><span class="line"> 9.         //3,key  </span><br><span class="line"> 10.         int key = a[ low ];  </span><br><span class="line"> 11.         //4，完成一趟排序  </span><br><span class="line"> 12.         while( i&lt; j) &#123;  </span><br><span class="line"> 13.             //4.1 ，从右往左找到第一个小于key的数  </span><br><span class="line"> 14.             while(i&lt;j &amp;&amp; a[j] &gt; key)&#123;  </span><br><span class="line"> 15.                 j--;  </span><br><span class="line"> 16.             &#125;  </span><br><span class="line"> 17.             // 4.2 从左往右找到第一个大于key的数  </span><br><span class="line"> 18.             while( i&lt;j &amp;&amp; a[i] &lt;= key) &#123;  </span><br><span class="line"> 19.                 i++;  </span><br><span class="line"> 20.             &#125;  </span><br><span class="line"> 21.             //4.3 交换  </span><br><span class="line"> 22.             if(i&lt;j) &#123;  </span><br><span class="line"> 23.                 int p = a[i];  </span><br><span class="line"> 24.                 a[i] = a[j];  </span><br><span class="line"> 25.                 a[j] = p;  </span><br><span class="line"> 26.             &#125;  </span><br><span class="line"> 27.         &#125;  </span><br><span class="line"> 28.         // 4.4，调整key的位置  </span><br><span class="line"> 29.         int p = a[i];  </span><br><span class="line"> 30.         a[i] = a[low];  </span><br><span class="line"> 31.         a[low] = p;  </span><br><span class="line"> 32.         //5, 对key左边的数快排  </span><br><span class="line"> 33.         quickSort(a, low, i-1 );  </span><br><span class="line"> 34.         //6, 对key右边的数快排  </span><br><span class="line"> 35.         quickSort(a, i+1, high);  </span><br><span class="line"> 36.     &#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-算法原理："><a href="#4-1-算法原理：" class="headerlink" title="4.1 算法原理："></a>4.1 算法原理：</h3><p>快速排序是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此实现整个数据变成有序序列。</p><h3 id="4-2-算法实现（Java）："><a href="#4-2-算法实现（Java）：" class="headerlink" title="4.2 算法实现（Java）："></a>4.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] array, int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int pivot = array[left];</span><br><span class="line">        int low = left;</span><br><span class="line">        int high = right;</span><br><span class="line">        while (low &lt; high) &#123;</span><br><span class="line">            while (low &lt; high &amp;&amp; array[high] &gt;= pivot) &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[low] = array[high];</span><br><span class="line">            while (low &lt; high &amp;&amp; array[low] &lt;= pivot) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            array[high] = array[low];</span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = pivot;</span><br><span class="line">        quickSort(array, left, low - 1);</span><br><span class="line">        quickSort(array, low + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>##5. 直接插入排序</p><h3 id="5-1-算法原理："><a href="#5-1-算法原理：" class="headerlink" title="5.1 算法原理："></a>5.1 算法原理：</h3><p>插入排序的基本方法是：每步将一个待排序序列按数据大小插到前面已经排序的序列中的适当位置，直到全部数据插入完毕为止。<br>假设有一组无序序列 , , … , ：<br>(1) 将这个序列的第一个元素R0视为一个有序序列；<br>(2) 依次把 , , … ,  插入到这个有序序列中；<br>(3) 将插入到有序序列中时，前 i-1 个数是有序的，将和 ~ 从后往前进行比较，确定要插入的位置。</p><h3 id="5-2-算法实现（Java）："><a href="#5-2-算法实现（Java）：" class="headerlink" title="5.2 算法实现（Java）："></a>5.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void insertSort(int[] array) &#123;</span><br><span class="line">    for (int i = 1, len = array.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (array[i] &lt; array[i - 1]) &#123;</span><br><span class="line">            int temp = array[i];</span><br><span class="line">            int j;</span><br><span class="line">            for (j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; array[j]; j--) &#123;</span><br><span class="line">                array[j + 1] = array[j];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Shell排序"><a href="#6-Shell排序" class="headerlink" title="6. Shell排序"></a>6. Shell排序</h2><h3 id="6-1-算法原理："><a href="#6-1-算法原理：" class="headerlink" title="6.1 算法原理："></a>6.1 算法原理：</h3><p>希尔排序是一种插入排序算法，又称作缩小增量排序。是对直接插入排序算法的改进。其基本思想是：<br>先取一个小于n的整数作为第一个增量，把全部数据分成个组。所有距离为的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量重复上述的分组和排序，直至所取的增量，即所有记录放在同一组中进行直接插入排序为止。该方法实质上是一种分组插入方法。</p><h3 id="6-2-算法实现（Java）："><a href="#6-2-算法实现（Java）：" class="headerlink" title="6.2 算法实现（Java）："></a>6.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void shellSort(int[] array) &#123;</span><br><span class="line">    int n = array.length;</span><br><span class="line">    int h;</span><br><span class="line">    for (h = n / 2; h &gt; 0; h /= 2) &#123;</span><br><span class="line">        for (int i = h; i &lt; n; i++) &#123;</span><br><span class="line">            for (int j = i - h; j &gt;= 0; j -= h) &#123;</span><br><span class="line">                if (array[j] &gt; array[j + h]) &#123;</span><br><span class="line">                    int temp = array[j];</span><br><span class="line">                    array[j] = array[j + h];</span><br><span class="line">                    array[j + h] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><h3 id="7-1-算法原理："><a href="#7-1-算法原理：" class="headerlink" title="7.1 算法原理："></a>7.1 算法原理：</h3><p>6.1.1 二叉堆定义：<br>二叉堆是完全二叉树或近似完全二叉树。二叉堆满足两个特性：<br>  1）父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。<br>  2）每个结点的左子树和右子树都是一个二叉堆。<br>当父结点的键值总是大于或等于任何一个子节点的键值时为大根堆。当父结点的键值总是小于或等于任何一个子节点的键值时为小根堆。下面展示一个小根堆： </p><p>由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。<br>6.1.2 堆的存储：<br>一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 <em> i + 1和2 </em> i + 2。如第0个结点左右子结点下标分别为1和2。 </p><p>6.1.3 堆的插入：<br>每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，然后将这个新数据插入到这个有序数据中。<br>6.1.4 堆排序：<br>堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]，小根堆则相反。<br>堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。<br>（1）用大根堆排序的基本思想<br>  ① 先将初始数组建成一个大根堆，此堆为初始的无序区<br>  ② 再将最大的元素（即堆顶）和无序区的最后一个记录交换，由此得到新的无序区和有序区，且满足的值&lt;=的值。<br>  ③由于交换后新的根可能违反堆性质，故应将当前无序区调整为堆。然后再次将中最大的元素和该区间的最后一个记录交换，由此得到新的无序区和有序区，且仍满足关系的值&lt;=的值，同样要将调整为堆。<br>……<br>直到无序区只有一个元素为止。<br>（2）大根堆排序算法的基本操作：<br>  ①建堆，建堆是不断调整堆的过程，从len/2处开始调整，一直到第一个节点，此处len是堆中元素的个数。建堆的过程是线性的过程，从len/2到0处一直调用调整堆的过程，相当于o(h1)+o(h2)…+o(hlen/2) 其中h表示节点的深度，len/2表示节点的个数，这是一个求和的过程，结果是线性的O(n)。<br>  ②调整堆：调整堆在构建堆的过程中会用到，而且在堆排序过程中也会用到。利用的思想是比较节点i和它的孩子节点left(i),right(i)，选出三者最大(或者最小)者，如果最大（小）值不是节点i而是它的一个孩子节点，那边交互节点i和该节点，然后再调用调整堆过程，这是一个递归的过程。调整堆的过程时间复杂度与堆的深度有关系，是lgn的操作，因为是沿着深度方向进行调整的。<br>  ③堆排序：堆排序是利用上面的两个过程来进行的。首先是根据元素构建堆。然后将堆的根节点取出(一般是与最后一个节点进行交换)，将前面len-1个节点继续进行堆调整的过程，然后再将根节点取出，这样一直到所有节点都取出。</p><p>###7.2 算法实现（Java）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void heapSort(int[] array) &#123;</span><br><span class="line">    // 1. 创建最大堆：从最后一个节点的父节点开始</span><br><span class="line">    int lastIndex = array.length - 1;</span><br><span class="line">    int startIndex = (lastIndex - 1) / 2;</span><br><span class="line">    for (int i = startIndex; i &gt;= 0; i--) &#123;</span><br><span class="line">        maxHeap(sort, sort.length, i);</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. 排序：末尾与头交换，逐一找出最大值，最终形成一个递增的有序序列</span><br><span class="line">    for (int i = array.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        int temp = array[0];</span><br><span class="line">        array[0] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">        maxHeap(array, i, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private static void maxHeap(int[] data, int heapSize, int index) &#123;</span><br><span class="line">    // 左子节点</span><br><span class="line">    int leftChild = 2 * index + 1;</span><br><span class="line">    // 右子节点</span><br><span class="line">    int rightChild = 2 * index + 2;</span><br><span class="line">    // 最大元素下标</span><br><span class="line">    int largestIndex = index;</span><br><span class="line">    // 分别比较当前节点和左右子节点，找出最大值</span><br><span class="line">    if (leftChild &lt; heapSize &amp;&amp; data[leftChild] &gt; data[largestIndex]) &#123;</span><br><span class="line">        largestIndex = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    if (rightChild &lt; heapSize &amp;&amp; data[rightChild] &gt; data[largestIndex]) &#123;</span><br><span class="line">        largestIndex = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果最大值是子节点，则进行交换</span><br><span class="line">    if (largestIndex != index) &#123;</span><br><span class="line">        int temp = data[index];</span><br><span class="line">        data[index] = data[largestIndex];</span><br><span class="line">        data[largestIndex] = temp;</span><br><span class="line">        // 交换后，其子节点可能就不是最大堆了，需要对交换的子节点重新调整</span><br><span class="line">        maxHeap(data, heapSize, largestIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-归并排序"><a href="#8-归并排序" class="headerlink" title="8. 归并排序"></a>8. 归并排序</h2><h3 id="8-1-算法原理："><a href="#8-1-算法原理：" class="headerlink" title="8.1 算法原理："></a>8.1 算法原理：</h3><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。<br>归并过程为：<br>  比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。<br>归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。<br>归并操作的工作原理如下：<br>  S1: 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>  S2: 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>  S3: 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>  S4: 重复S3，直到某一指针超出序列尾<br>  S5: 将另一序列剩下的所有元素直接复制到合并序列尾</p><h3 id="8-2-算法实现（Java）："><a href="#8-2-算法实现（Java）：" class="headerlink" title="8.2 算法实现（Java）："></a>8.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void mergeSort(int[] array, int low, int high) &#123;</span><br><span class="line">    int middle = (low + high) / 2;</span><br><span class="line">    if (low &lt; high) &#123;</span><br><span class="line">        mergeSort(array, low, middle);</span><br><span class="line">        mergeSort(array, middle + 1, high);</span><br><span class="line">        merge(array, low, middle, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static void merge(int[] array, int low, int middle, int high) &#123;</span><br><span class="line">    int[] temp = new int[high - low + 1];</span><br><span class="line">    int i = low;</span><br><span class="line">    int j = middle + 1;</span><br><span class="line">    int k = 0;</span><br><span class="line">    while (i &lt;= middle &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">        if (array[i] &lt; array[j]) &#123;</span><br><span class="line">            temp[k++] = array[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[k++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;= middle) &#123;</span><br><span class="line">        temp[k++] = array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;= high) &#123;</span><br><span class="line">        temp[k++] = array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int m = 0; m &lt; temp.length; m++) &#123;</span><br><span class="line">        array[m + low] = temp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-基数排序"><a href="#9-基数排序" class="headerlink" title="9. 基数排序"></a>9. 基数排序</h2><h3 id="9-1-算法原理："><a href="#9-1-算法原理：" class="headerlink" title="9.1 算法原理："></a>9.1 算法原理：</h3><p>基数排序的原理如下：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。<br>基数排序的方式有以下两种：<br>  最高位优先(Most Significant Digit first)法，简称MSD法：先按排序分组，同一组中记录，关键码相等，再对各组按排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码对各子组排序后。再将各组连接起来，便得到一个有序序列。<br>  最低位优先(Least Significant Digit first)法，简称LSD法：先从开始排序，再对进行排序，依次重复，直到对排序后便得到一个有序序列。</p><h3 id="9-2-算法实现（Java）："><a href="#9-2-算法实现（Java）：" class="headerlink" title="9.2 算法实现（Java）："></a>9.2 算法实现（Java）：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 基数排序(LSD)</span><br><span class="line"> *</span><br><span class="line"> * @param array 待排序数组</span><br><span class="line"> * @param d     表示最大的元素的位数</span><br><span class="line"> */</span><br><span class="line">public static void radixSort(int[] array, int d) &#123;</span><br><span class="line">    int n = 1;</span><br><span class="line">    int times = 1; // 排序次数，由位数最多的元素决定</span><br><span class="line">    int[][] temp = new int[10][array.length]; //数组的第一维表示可能的余数0-9</span><br><span class="line">    int[] order = new int[10]; //数组order用来表示该位是i的元素个数</span><br><span class="line">    while (times &lt;= d) &#123;</span><br><span class="line">        for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            int lsd = ((array[i] / n) % 10);</span><br><span class="line">            temp[lsd][order[lsd]] = array[i];</span><br><span class="line">            order[lsd]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int k = 0;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            if (order[i] != 0) &#123;</span><br><span class="line">                for (int j = 0; j &lt; order[i]; j++) &#123;</span><br><span class="line">                    array[k] = temp[i][j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">                order[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= 10;</span><br><span class="line">        times++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android git需要忽略文件</title>
      <link href="/2018/05/20/Android%20git%E9%9C%80%E8%A6%81%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/"/>
      <url>/2018/05/20/Android%20git%E9%9C%80%E8%A6%81%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="要忽略的文件"><a href="#要忽略的文件" class="headerlink" title="要忽略的文件"></a>要忽略的文件</h3><ul><li>.idea 文件夹 </li><li>.gradle 文件夹 </li><li>所有的 build 文件夹 </li><li>所有的 .iml 文件 </li><li>local.properties 文件</li></ul><p>所以： </p><h3 id="跟目录下的文件："><a href="#跟目录下的文件：" class="headerlink" title="跟目录下的文件："></a>跟目录下的文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">.gradle</span><br><span class="line">/local.properties</span><br><span class="line">/.idea/workspace.xml</span><br><span class="line">/.idea/libraries</span><br><span class="line">.DS_Store</span><br><span class="line">/build</span><br><span class="line">/captures</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><h3 id="module目录下的文件："><a href="#module目录下的文件：" class="headerlink" title="module目录下的文件："></a>module目录下的文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">/build</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p><img src="http://p86p0tig8.bkt.clouddn.com/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE%E6%88%AA%E5%9B%BE.jpg" alt="git忽略文件设置"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GreenDao理解及简单使用</title>
      <link href="/2018/05/20/GreenDao%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/05/20/GreenDao%E7%90%86%E8%A7%A3%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="关于greenDAO"><a href="#关于greenDAO" class="headerlink" title="关于greenDAO"></a>关于greenDAO</h2><p>greenDAO应该算是当前最火的数据库开源框架了，它是一个将对象映射到SQLite数据库中的轻量且快速的ORM（object / relational mapping）解决方案。<br><img src="http://upload-images.jianshu.io/upload_images/2256198-2473f62d038035ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="greenDAO-orm"><br>关于greenDAO的其他相关信息可以看官网<a href="http://greenrobot.org/greendao/" target="_blank" rel="noopener">greenDAO</a>、<br><a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="noopener">githubgreenDAO地址</a>、<a href="http://greenrobot.org/greendao/documentation/introduction/" target="_blank" rel="noopener">官方的配置GreenDAO英文文档</a></p><h2 id="greenDAO理解"><a href="#greenDAO理解" class="headerlink" title="greenDAO理解"></a>greenDAO理解</h2><p> DAO的core library中有以下几个核心类，也是后面常用到的，先来大概了解下他们的结构，不然直接看他们的使用会云里雾里。</p><p><img src="http://upload-images.jianshu.io/upload_images/2256198-8708569f13e6b9f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Core-Classes"></p><ul><li><p><strong>DaoMaster</strong>：Dao中的管理者。它保存了sqlitedatebase对象以及操作DAO classes（注意：不是对象）。其提供了一些创建和删除table的静态方法，其内部类OpenHelper和DevOpenHelper实现了<br>SQLiteOpenHelper，并创建数据库的框架。</p></li><li><p><strong>DaoSession</strong>：会话层。操作具体的DAO对象（注意：是对象），比如各种getter方法。</p></li><li><p><strong>Daos</strong>：实际生成的某某DAO类，通常对应具体的java类，比如NoteDao等。其有更多的权限和方法来操作数据库元素。</p></li><li><p><strong>Entities</strong>：持久的实体对象。通常代表了一个数据库row的标准java properties。</p></li></ul><h2 id="greenDAO优势"><a href="#greenDAO优势" class="headerlink" title="greenDAO优势"></a>greenDAO优势</h2><p>1、一个精简的库<br>2、性能最大化<br>3、内存开销最小化<br>4、易于使用的 APIs<br>5、对 Android 进行高度优化<br>有兴趣的可以看下官网的 <a href="http://greenrobot.org/greendao/features/" target="_blank" rel="noopener">greenDAO Features</a></p><h2 id="greenDAO使用"><a href="#greenDAO使用" class="headerlink" title="greenDAO使用"></a>greenDAO使用</h2><p>greenDAO3.0采用注解的方式来定义实体类，通过gradle插件生成相应的代码。</p><h3 id="1，首先在project的gradle文件中引入greenDAO插件，引入之后如下："><a href="#1，首先在project的gradle文件中引入greenDAO插件，引入之后如下：" class="headerlink" title="1，首先在project的gradle文件中引入greenDAO插件，引入之后如下："></a>1，首先在<code>project的gradle</code>文件中引入greenDAO插件，引入之后如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// In your root build.gradle file:</span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral() // add repository</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &apos;com.android.tools.build:gradle:3.0.0&apos;</span><br><span class="line">        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，然后在module的gradle文件中添加greenDAO的插件，并引入相关类库，修改之后如下："><a href="#2，然后在module的gradle文件中添加greenDAO的插件，并引入相关类库，修改之后如下：" class="headerlink" title="2，然后在module的gradle文件中添加greenDAO的插件，并引入相关类库，修改之后如下："></a>2，然后在<code>module的gradle</code>文件中添加greenDAO的插件，并引入相关类库，修改之后如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// In your app projects build.gradle file:</span><br><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin</span><br><span class="line"></span><br><span class="line">android &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    ...  </span><br><span class="line">  </span><br><span class="line">    greendao&#123;  </span><br><span class="line">        schemaVersion 1  </span><br><span class="line">        daoPackage &apos;com.greendao.gen&apos;</span><br><span class="line">        targetGenDir &apos;src/main/java&apos;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line">dependencies &#123;  </span><br><span class="line">    ...  </span><br><span class="line">    ...  </span><br><span class="line">    implementation &apos;org.greenrobot:greendao:3.2.2&apos; // add library</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在gradle的根模块中加入上述代码，就完成了我们的基本配置了。<br>属性介绍：<br>schemaVersion–&gt; 指定数据库schema版本号，迁移等操作会用到;<br>daoPackage –&gt; dao的包名，包名默认是entity所在的包；<br>targetGenDir –&gt; 生成数据库文件的目录;</p><h3 id="3，创建一个User的实体类"><a href="#3，创建一个User的实体类" class="headerlink" title="3，创建一个User的实体类"></a>3，创建一个User的实体类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Id </span><br><span class="line">    private Long id; </span><br><span class="line">    @Property(nameInDb = &quot;NAME&quot;)</span><br><span class="line">    private String name; </span><br><span class="line">    @Transient </span><br><span class="line">    private int tempUsageCount; // not persisted  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@Entity</strong> 表示这个实体类一会会在数据库中生成对应的表，</li><li><strong>@Id</strong> 表示该字段是id，注意该字段的数据类型为包装类型Long</li><li><strong>@Property</strong> 则表示该属性将作为表的一个字段，其中nameInDb看名字就知道这个属性在数据库中对应的数据名称。</li><li><strong>@Transient</strong> 该注解表示这个属性将不会作为数据表中的一个字段。</li><li><strong>@NotNull</strong> 表示该字段不可以为空</li><li><strong>@Unique</strong> 表示该字段唯一。小伙伴们有兴趣可以自行研究。<h3 id="4，MakeProject"><a href="#4，MakeProject" class="headerlink" title="4，MakeProject"></a>4，MakeProject</h3>编译项目（Android快捷键：Ctrl+F9），User实体类会自动编译，生成get、set方法并且会在com.greendao.gen目录下生成三个文件,并且还会在我们的包下生成DaoMaster和DaoSession。<h2 id="greenDAO使用-1"><a href="#greenDAO使用-1" class="headerlink" title="greenDAO使用"></a>greenDAO使用</h2>步骤：即：先创建了一个SQLiteOpenHelper并创建连接到一个具体数据库；再根据具体的datebase创建一个master对象用于；最后通过master创建一个数据库的会话操作。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> public class MyApplication extends Application &#123;</span><br><span class="line"> private DaoMaster.DevOpenHelper mHelper;</span><br><span class="line"> private SQLiteDatabase db;</span><br><span class="line"> private DaoMaster mDaoMaster;</span><br><span class="line"> private DaoSession mDaoSession;</span><br><span class="line"> public static MyApplication instances;</span><br><span class="line"> @Override    public void onCreate() &#123;</span><br><span class="line">     super.onCreate();</span><br><span class="line">     instances = this;</span><br><span class="line">     setDatabase();</span><br><span class="line"> &#125;</span><br><span class="line"> public static MyApplication getInstances()&#123;</span><br><span class="line">     return instances;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 设置greenDAO</span><br><span class="line"> */</span><br><span class="line">private void setDatabase() &#123;</span><br><span class="line">    // 通过 DaoMaster 的内部类 DevOpenHelper，你可以得到一个便利的 SQLiteOpenHelper 对象。</span><br><span class="line">    // 可能你已经注意到了，你并不需要去编写「CREATE TABLE」这样的 SQL 语句，因为 greenDAO已经帮你做了。</span><br><span class="line">    // 注意：默认的 DaoMaster.DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失。</span><br><span class="line">    // 所以，在正式的项目中，你还应该做一层封装，来实现数据库的安全升级。</span><br><span class="line">    mHelper = new DaoMaster.DevOpenHelper(this, &quot;notes-db&quot;, null);</span><br><span class="line">    db = mHelper.getWritableDatabase();</span><br><span class="line">    // 注意：该数据库连接属于 DaoMaster，所以多个 Session 指的是相同的数据库连接。 </span><br><span class="line">    mDaoMaster = new DaoMaster(db); </span><br><span class="line">    mDaoSession = mDaoMaster.newSession();</span><br><span class="line">&#125;</span><br><span class="line">public DaoSession getDaoSession() &#123;</span><br><span class="line">      return mDaoSession;</span><br><span class="line">&#125;</span><br><span class="line">public SQLiteDatabase getDb() &#123;</span><br><span class="line">      return db;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>获取UserDao对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDao mUserDao = MyApplication.getInstances().getDaoSession().getUserDao();</span><br></pre></td></tr></table></figure></p><h2 id="简单的增删改查实现："><a href="#简单的增删改查实现：" class="headerlink" title="简单的增删改查实现："></a>简单的增删改查实现：</h2><ol><li><p>增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mUser = new User((long)2,&quot;anye3&quot;);</span><br><span class="line">mUserDao.insert(mUser);//添加一个</span><br></pre></td></tr></table></figure></li><li><p>删</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mUserDao.deleteByKey(id);</span><br></pre></td></tr></table></figure></li><li><p>改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mUser = new User((long)2,&quot;anye0803&quot;);</span><br><span class="line">mUserDao.update(mUser);</span><br></pre></td></tr></table></figure></li><li><p>查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = mUserDao.loadAll();</span><br><span class="line">String userName = &quot;&quot;;</span><br><span class="line">for (int i = 0; i &lt; users.size(); i++) &#123;</span><br><span class="line">    userName += users.get(i).getName()+&quot;,&quot;;</span><br><span class="line">&#125;</span><br><span class="line">mContext.setText(&quot;查询全部数据==&gt;&quot;+userName);</span><br></pre></td></tr></table></figure></li></ol><p>更多的操作就不一一介绍了，大家可以根据需要去查找资料；</p><h2 id="greenDAO中的注解"><a href="#greenDAO中的注解" class="headerlink" title="greenDAO中的注解"></a>greenDAO中的注解</h2><p>(一) @Entity 定义实体<br>@nameInDb 在数据库中的名字，如不写则为实体中类名<br>@indexes 索引<br>@createInDb 是否创建表，默认为true,false时不创建<br>@schema 指定架构名称为实体<br>@active 无论是更新生成都刷新<br>(二) @Id<br>(三) @NotNull 不为null<br>(四) @Unique 唯一约束<br>(五) @ToMany 一对多<br>(六) @OrderBy 排序<br>(七) @ToOne 一对一<br>(八) @Transient 不存储在数据库中<br>(九) @generated 由greenDAO产生的构造函数或方法</p><h2 id="数据库升级"><a href="#数据库升级" class="headerlink" title="数据库升级"></a>数据库升级</h2><p>数据库的升级其实就两个步骤我们来看看：<br>8.1 修改gradle文件<br>首先在module的gradle文件中修改版本号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//这里改为最新的版本号  </span><br><span class="line">schemaVersion 2  </span><br><span class="line">targetGenDir &apos;src/main/java&apos;</span><br></pre></td></tr></table></figure></p><p>8.2修改实体类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Entity  </span><br><span class="line">public class User &#123;  </span><br><span class="line">    @Property  </span><br><span class="line">    private int age;  </span><br><span class="line">    @Property  </span><br><span class="line">    private String password;  </span><br><span class="line">    @Id  </span><br><span class="line">    private Long id;  </span><br><span class="line">    @Property(nameInDb = &quot;USERNAME&quot;)  </span><br><span class="line">    private String username;  </span><br><span class="line">    @Property(nameInDb = &quot;NICKNAME&quot;)  </span><br><span class="line">    private String nickname;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重现编译项目运行即可。<br>一般的数据库升级这样就可以了，特殊情况可能需要自己编写数据库迁移脚本，这种时候可以自定义DBHelper，定义方式如下，注意继承类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class DBHelper extends DaoMaster.OpenHelper &#123;  </span><br><span class="line">    public static final String DBNAME = &quot;lenve.db&quot;;  </span><br><span class="line">  </span><br><span class="line">    public DBHelper(Context context) &#123;  </span><br><span class="line">        super(context, DBNAME, null);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    @Override  </span><br><span class="line">    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123;  </span><br><span class="line">        super.onUpgrade(db, oldVersion, newVersion);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以在onUpgrade方法中进行数据库的迁移，如果自定义了DBHelper，则数据库的初始化变为如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBHelper devOpenHelper = new DBHelper(this);  </span><br><span class="line">DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDb());  </span><br><span class="line">DaoSession daoSession = daoMaster.newSession();  </span><br><span class="line">userDao = daoSession.getUserDao();</span><br></pre></td></tr></table></figure></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>总体来说,greenDAO在配置上相对于2.0要简单的多。<br>本文 Demo 下载链接：<a href="https://github.com/YangJiexian/greenDAODemo" target="_blank" rel="noopener">greenDAODemo</a>，如果喜欢的话可以star一下。<br>本教程旨在介绍 greenDAO3.0的基本用法与配置，更高级与详细的使用，请参见官网如本文有任何问题欢迎指正。</p>]]></content>
      
      
      <categories>
          
          <category> GreenDAO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> basis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownTimer</title>
      <link href="/2018/05/09/CountDownTimer%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/05/09/CountDownTimer%E4%BD%BF%E7%94%A8%E5%92%8C%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在项目开发中经常会用到倒计时这个功能，而Android也帮我们封装好了一个类CountDownTimer，给我们的开发带来了很大的方便；</p><h2 id="二、API"><a href="#二、API" class="headerlink" title="二、API"></a>二、API</h2><p>CountDownTimer (long millisInFuture, long countDownInterval)<br>参数1，设置倒计时的总时间（毫秒）<br>参数2，设置每次减去多少毫秒</p><h2 id="三、基本用法"><a href="#三、基本用法" class="headerlink" title="三、基本用法"></a>三、基本用法</h2><h2 id="以App中获短信取验证码为例："><a href="#以App中获短信取验证码为例：" class="headerlink" title="以App中获短信取验证码为例："></a>以App中获短信取验证码为例：</h2><p>private Button btn;<br>    private TextView vertifyView;  </p><pre><code>@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    initView();}private void initView(){    vertifyView =(TextView) findViewById(R.id.vertifyView);    btn =(Button) findViewById(R.id.button);    btn.setOnClickListener(new View.OnClickListener() {        @Override        public void onClick(View v) {            //1,请求后台...            //2,触发定时器刷新UI（启动代码最好放在请求后台回调成功之后）            timer.start();        }    });}private CountDownTimer timer = new CountDownTimer(10000, 1000) {      @Override      public void onTick(long millisUntilFinished) {          vertifyView.setText((millisUntilFinished / 1000) + &quot;秒后可重发&quot;);      }      @Override      public void onFinish() {          vertifyView.setEnabled(true);          vertifyView.setText(&quot;获取验证码&quot;);      }  };  </code></pre><hr><h2 id="四、存在的问题"><a href="#四、存在的问题" class="headerlink" title="四、存在的问题"></a>四、存在的问题</h2><p>CountDownTimer如果使用不当，常常会报空指针异常，甚至造成严重的内存泄漏<br>5.0源码：<br>-</p><p>public abstract class CountDownTimer {</p><pre><code>/** * Millis since epoch when alarm should stop. */private final long mMillisInFuture;/** * The interval in millis that the user receives callbacks */private final long mCountdownInterval;private long mStopTimeInFuture;/*** boolean representing if the timer was cancelled*/private boolean mCancelled = false;/** * @param millisInFuture The number of millis in the future from the call *   to {@link #start()} until the countdown is done and {@link #onFinish()} *   is called. * @param countDownInterval The interval along the way to receive *   {@link #onTick(long)} callbacks. */public CountDownTimer(long millisInFuture, long countDownInterval) {    mMillisInFuture = millisInFuture;    mCountdownInterval = countDownInterval;}/** * Cancel the countdown. */public synchronized final void cancel() {    mCancelled = true;    mHandler.removeMessages(MSG);}/** * Start the countdown. */public synchronized final CountDownTimer start() {    mCancelled = false;    if (mMillisInFuture &lt;= 0) {        onFinish();        return this;    }    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;    mHandler.sendMessage(mHandler.obtainMessage(MSG));    return this;}/** * Callback fired on regular interval. * @param millisUntilFinished The amount of time until finished. */public abstract void onTick(long millisUntilFinished);/** * Callback fired when the time is up. */public abstract void onFinish();private static final int MSG = 1;// handles counting downprivate Handler mHandler = new Handler() {    @Override    public void handleMessage(Message msg) {        synchronized (CountDownTimer.this) {            if (mCancelled) {                return;            }            final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime();            if (millisLeft &lt;= 0) {                onFinish();            } else if (millisLeft &lt; mCountdownInterval) {                // 剩余时间小于一次时间间隔的时候，不再通知，只是延迟一下                sendMessageDelayed(obtainMessage(MSG), millisLeft);            } else {                long lastTickStart = SystemClock.elapsedRealtime();                onTick(millisLeft);                 // 处理用户onTick执行的时间                long delay = lastTickStart + mCountdownInterval - SystemClock.elapsedRealtime();                 // 特殊情况：用户的onTick方法花费的时间比interval长，那么直接跳转到下一次interval                while (delay &lt; 0) delay += mCountdownInterval;                sendMessageDelayed(obtainMessage(MSG), delay);            }        }    }};</code></pre><p>}</p><p>-</p><p>从源码中我们可以看出，CountDownTimer的内部实现是采用Handler机制，通过sendMessageDelayed延迟发送一条message到主线程的looper中，然后在自身中收到之后判断剩余时间，并发出相关回调，然后再次发出message的方式。</p><p>这样的方式其实是有一定弊端的，那就是如果在Activity或者Fragment被回收时并未调用CountDownTimer的cancel()方法结束自己，这个时候CountDownTimer的Handler方法中如果判断到当前的时间未走完，那么会继续调用</p><p>sendMessageDelayed(obtainMessage(MSG), delay);</p><p>触发</p><p>onTick(millisLeft);</p><p>当回调了Activity或者fragment中CountDownTimer的onTick方法时，Activity或者Fragment已经被系统回收，从而里面的变量被设置为Null，再调用</p><p>vertifyView.setText((millisUntilFinished / 1000) + “秒后可重发”);</p><p>vertifyView为空，也就空指针了~<br>同时，CountDownTimer中的Handler方法还在继续执行，这一块空间始终无法被系统回收也就造成了内存泄漏问题。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>1，在CountDownTimer的onTick方法中记得判空</p><hr><p>activity中<br>    if(!activity.isFinishing()){<br>        //doing something…<br>    }</p><p>fragment中<br>    if(getActivity()!=null){<br>       //doing something…</p><pre><code>}</code></pre><hr><p>2，在配合DialogFragment使用时，如果在onFinish()方法调用了 dismiss()方法让弹框消失，记得 判断getFragmentManager是否为空</p><pre><code>@Overridepublic void onFinish() {    if(getFragmentManager()!=null){        dismiss();    }}</code></pre><p>3，在使用CountDownTimer时，在宿主Activity或fragment生命周期结束的时候，记得调用timer.cancle()方法</p><p>@Override<br>    public void onDestroy() {<br>        if(timer!=null){<br>            timer.cancel();<br>            timer = null;<br>        }<br>        super.onDestroy();<br>    }</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> CountDownTimer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android横竖切换</title>
      <link href="/2018/05/09/Activity%E6%A8%AA%E7%AB%96%E5%88%87%E6%8D%A2/"/>
      <url>/2018/05/09/Activity%E6%A8%AA%E7%AB%96%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://p86p0tig8.bkt.clouddn.com/Android%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="Android横竖切换知识点"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2018/05/09/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/05/09/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>基本技巧<br>代码<br>如果你只想高亮语句中的某个函数名或关键字，可以使用 <code>function_name()</code> 实现</p><p>通常编辑器根据代码片段适配合适的高亮方法，但你也可以用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&apos;hello world&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>支持的语言：1c, abnf, accesslog, actionscript, ada, apache, applescript, arduino, armasm, asciidoc, aspectj, autohotkey, autoit, avrasm, awk, axapta, bash, basic, bnf, brainfuck, cal, capnproto, ceylon, clean, clojure, clojure-repl, cmake, coffeescript, coq, cos, cpp, crmsh, crystal, cs, csp, css, d, dart, delphi, diff, django, dns, dockerfile, dos, dsconfig, dts, dust, ebnf, elixir, elm, erb, erlang, erlang-repl, excel, fix, flix, fortran, fsharp, gams, gauss, gcode, gherkin, glsl, go, golo, gradle, groovy, haml, handlebars, haskell, haxe, hsp, htmlbars, http, hy, inform7, ini, irpf90, java, javascript, json, julia, kotlin, lasso, ldif, leaf, less, lisp, livecodeserver, livescript, llvm, lsl, lua, makefile, markdown, mathematica, matlab, maxima, mel, mercury, mipsasm, mizar, mojolicious, monkey, moonscript, n1ql, nginx, nimrod, nix, nsis, objectivec, ocaml, openscad, oxygene, parser3, perl, pf, php, pony, powershell, processing, profile, prolog, protobuf, puppet, purebasic, python, q, qml, r, rib, roboconf, rsl, ruby, ruleslanguage, rust, scala, scheme, scilab, scss, smali, smalltalk, sml, sqf, sql, stan, stata, step21, stylus, subunit, swift, taggerscript, tap, tcl, tex, thrift, tp, twig, typescript, vala, vbnet, vbscript, vbscript-html, verilog, vhdl, vim, x86asm, xl, xml, xquery, yaml, zephir</p><p>也可以使用 4 空格缩进，再贴上代码，实现相同的的效果</p><pre><code>def g(x):    yield from range(x, 0, -1)yield from range(x)</code></pre><p>如你不需要代码高亮，可以用下面的方法禁用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">标题</span><br><span class="line">文章内容较多时，可以用标题分段：</span><br><span class="line"></span><br><span class="line">标题1</span><br><span class="line">======</span><br><span class="line"></span><br><span class="line">标题2</span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">## 大标题 ##</span><br><span class="line">### 小标题 ###</span><br><span class="line">粗斜体</span><br><span class="line">*斜体文本*    _斜体文本_</span><br><span class="line">**粗体文本**    __粗体文本__</span><br><span class="line">***粗斜体文本***    ___粗斜体文本___</span><br><span class="line">链接</span><br><span class="line">常用链接方法</span><br><span class="line"></span><br><span class="line">文字链接 [链接名称](http://链接网址)</span><br><span class="line">网址链接 &lt;http://链接网址&gt;</span><br><span class="line">高级链接技巧</span><br><span class="line"></span><br><span class="line">这个链接用 1 作为网址变量 [Google][1].</span><br><span class="line">这个链接用 yahoo 作为网址变量 [Yahoo!][yahoo].</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http://www.google.com/</span><br><span class="line">  [yahoo]: http://www.yahoo.com/</span><br><span class="line">列表</span><br><span class="line">普通无序列表</span><br><span class="line"></span><br><span class="line">- 列表文本前使用 [减号+空格]</span><br><span class="line">+ 列表文本前使用 [加号+空格]</span><br><span class="line">* 列表文本前使用 [星号+空格]</span><br><span class="line">普通有序列表</span><br><span class="line"></span><br><span class="line">1. 列表前使用 [数字+空格]</span><br><span class="line">2. 我们会自动帮你添加数字</span><br><span class="line">7. 不用担心数字不对，显示的时候我们会自动把这行的 7 纠正为 3</span><br><span class="line">列表嵌套</span><br><span class="line"></span><br><span class="line">1. 列出所有元素：</span><br><span class="line">    - 无序列表元素 A</span><br><span class="line">        1. 元素 A 的有序子列表</span><br><span class="line">    - 前面加四个空格</span><br><span class="line">2. 列表里的多段换行：</span><br><span class="line">    前面必须加四个空格，</span><br><span class="line">    这样换行，整体的格式不会乱</span><br><span class="line">3. 列表里引用：</span><br><span class="line"></span><br><span class="line">    &gt; 前面空一行</span><br><span class="line">    &gt; 仍然需要在 &gt;  前面加四个空格</span><br><span class="line"></span><br><span class="line">4. 列表里代码段：</span><br></pre></td></tr></table></figure><pre><code>前面四个空格，之后按代码语法 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>    或者直接空八个，引入代码块</code></pre><p>引用<br>普通引用</p><blockquote><p>引用文本前使用 [大于号+空格]<br>折行可以不加，新起一行都要加上哦<br>引用里嵌套引用</p></blockquote><blockquote><p>最外层引用</p><blockquote><p>多一个 &gt; 嵌套一层引用</p><blockquote><p>可以嵌套很多层<br>引用里嵌套列表</p></blockquote></blockquote></blockquote><blockquote><ul><li>这是引用里嵌套的一个列表</li><li>还可以有子列表<ul><li>子列表需要从 - 之后延后四个空格开始<br>引用里嵌套代码块</li></ul></li></ul></blockquote><blockquote><pre><code>同样的，在前面加四个空格形成代码块</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 或者使用 ``` 形成代码块</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>图片<br>跟链接的方法区别在于前面加了个感叹号 !，这样是不是觉得好记多了呢？</p><p><img src="http://图片网址" alt="图片名称"><br>当然，你也可以像网址那样对图片网址使用变量</p><p>这个链接用 1 作为网址变量 <a href="http://www.google.com/logo.png" target="_blank" rel="noopener">Google</a>.<br>然后在文档的结尾位变量赋值（网址）</p><p>换行<br>如果另起一行，只需在当前行结尾加 2 个空格</p><p>在当前行的结尾加 2 个空格<br>这行就会新起一行<br>如果是要起一个新段落，只需要空出一行即可。</p><p>分隔符<br>如果你有写分割线的习惯，可以新起一行输入三个减号-。当前后都有段落时，请空出一行：</p><p>前面的段落</p><hr><p>后面的段落</p><p>高级技巧<br>行内 HTML 元素<br>目前只支持部分段内 HTML 元素效果，包括 <kdb> <b> <i> <em> <sup> <sub> <br> ，如</sub></sup></em></i></b></kdb></p><p>键位显示</p><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑<br>代码块</p><p>使用 <pre></pre> 元素同样可以形成代码块<br>粗斜体</p><p><b> Markdown 在此处同样适用，如 <em>加粗</em> </b><br>符号转义<br>如果你的描述中需要用到 markdown 的符号，比如 _ # <em> 等，但又不想它被转义，这时候可以在这些符号前加反斜杠，如 _ # \</em> 进行避免。</p><p>_不想这里的文本变斜体_<br>**不想这里的文本被加粗**<br>扩展<br>支持 jsfiddle、gist、runjs、优酷视频，直接填写 url，在其之后会自动添加预览点击会展开相关内容。</p><p>http://{url_of_the_fiddle}/embedded/[{tabs}/[{style}]]/<br><a href="https://gist.github.com/{gist_id}" target="_blank" rel="noopener">https://gist.github.com/{gist_id}</a><br><a href="http://runjs.cn/detail/{id}" target="_blank" rel="noopener">http://runjs.cn/detail/{id}</a><br><a href="http://v.youku.com/v_show/id_{video_id}.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_{video_id}.html</a><br>公式<br>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><p>$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$</p><p>$$<br>x \href{why-equal.html}{=} y^2 + 1<br>$$<br>同时也支持 HTML 属性，如：</p><p>$$ (x+1)^2 = \class{hidden}{(x+1)(x+1)} $$</p><p>$$<br>(x+1)^2 = \cssId{step1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC,MVP,MVVM的图示</title>
      <link href="/2018/04/30/MVC,MVP,MVVM%E7%9A%84%E5%9B%BE%E7%A4%BA/"/>
      <url>/2018/04/30/MVC,MVP,MVVM%E7%9A%84%E5%9B%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。<br>一句话介绍就是：MVC单向通信，MVP双向通信，MVVM双向数据绑定。</p><h2 id="一、MVC"><a href="#一、MVC" class="headerlink" title="一、MVC"></a>一、MVC</h2><p>MVC模式的意思是，软件可以分成三个部分。<br><img src="http://p86p0tig8.bkt.clouddn.com/mvc%E6%A8%A1%E5%9D%97.png" alt="这里写图片描述"></p><ul><li>视图（View）：用户界面。 </li><li>控制器（Controller）：业务逻辑 </li><li>模型（Model）：数据保存</li></ul><p>各部分之间的通信方式如下。</p><p><img src="http://p86p0tig8.bkt.clouddn.com/mvc%E5%85%B3%E7%B3%BB.png" alt="这里写图片描述"></p><ul><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li></ul><p>所有通信都是单向的。</p><h3 id="1、互动模式"><a href="#1、互动模式" class="headerlink" title="1、互动模式"></a>1、互动模式</h3><p>接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。</p><p><img src="http://p86p0tig8.bkt.clouddn.com/MVC%E5%BC%80%E5%90%AF%E4%B8%80.png" alt="这里写图片描述"></p><p>另一种是直接通过controller接受指令。</p><p><img src="http://p86p0tig8.bkt.clouddn.com/MVC%E5%BC%80%E5%90%AF%E4%BA%8C.png" alt="这里写图片描述"></p><h3 id="2、实例：Backbone"><a href="#2、实例：Backbone" class="headerlink" title="2、实例：Backbone"></a>2、实例：Backbone</h3><p>实际项目往往采用更灵活的方式，以 Backbone.js 为例。</p><p><img src="http://p86p0tig8.bkt.clouddn.com/MVC%E4%B8%89.png" alt="这里写图片描述"></p><ol><li><p>用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</p></li><li><p>用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</p></li><li><p>Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</p></li></ol><h2 id="二、MVP"><a href="#二、MVP" class="headerlink" title="二、MVP"></a>二、MVP</h2><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p><p><img src="http://p86p0tig8.bkt.clouddn.com/mvp%E6%B5%81%E7%A8%8B.png" alt="这里写图片描述"></p><ol><li><p>各部分之间的通信，都是双向的。</p></li><li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p></li><li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p></li></ol><h2 id="三、MVVM"><a href="#三、MVVM" class="headerlink" title="三、MVVM"></a>三、MVVM</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p><p><img src="http://p86p0tig8.bkt.clouddn.com/mvvm%E6%B5%81%E7%A8%8B.png" alt="这里写图片描述"></p><p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> MVP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> MVP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开发者基础</title>
      <link href="/2018/04/25/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/04/25/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p>onCreate </p><p>onStart</p><p>onResume</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发者基础</title>
      <link href="/2018/04/25/Java%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/04/25/Java%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p>onCreate </p><p>onStart</p><p>onResume</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
